import dotenv from "dotenv";
import axios from "axios";
import * as cheerio from "cheerio";
import {
  ButtonBuilder,
  ButtonStyle,
  ContainerBuilder,
  TextDisplayBuilder,
  SectionBuilder,
  MessageFlags,
  SeparatorSpacingSize,
} from "discord.js";
import { requestAI } from "../../utils/ai-request.js";
import { scrapeBgJargon } from "../../utils/bgjargon-scraper.js";

dotenv.config();

const wordCommand = {
  data: {
    name: "word",
    type: 1,
    description:
      "Get information about a Bulgarian word through https://rechnik.chitanka.info/",
    options: [
      {
        name: "word",
        description: "The word",
        required: true,
        type: 3,
      },
      {
        name: "hidden",
        description: "Do you want to hide the answer from other users?",
        required: false,
        type: 5,
      },
    ],
    integration_types: [0, 1],
    contexts: [0, 1, 2],
  },
  async execute(interaction) {
    const word = interaction.options.getString("word");
    const hidden = interaction.options.getBoolean("hidden");

    await interaction.deferReply({ ephemeral: hidden });

    try {
      const response = await axios.get(
        `https://rechnik.chitanka.info/w/${encodeURIComponent(word)}`
      );
      const $ = cheerio.load(response.data);

     const title = $("h1#first-heading").text().trim();
     const stressedWord = $("[id^='name-stressed_']").first().text().trim();

     const typeElement = $("[id^='type_']");
     let typeText = "";
     let typeLink = "";

     if (typeElement.length) {
       typeText = typeElement.text().trim();
       const linkElement = typeElement.find("a");
       if (linkElement.length) {
         const href = linkElement.attr("href");
         typeLink = `https://rechnik.chitanka.info${href}`;
       }
     }

     const [wordType, wordClass] = typeText.split("(");
     const wordClassClean = wordClass ? `(${wordClass.trim()}` : "";

     const meaningElement = $("[id^='meaning_']");
     const meaning = meaningElement.length ? meaningElement.text().trim() : "";
     
      const synonyms = $(".synonyms .data").text().trim();
      const links = $(".links .data ul li")
        .map((i, el) => {
          const linkText = $(el).text().trim();
          const linkUrl = $(el).find("a").attr("href");
          return `[${linkText}](${linkUrl})`;
        })
        .get()
        .join("\n");

      const container = new ContainerBuilder();

      const titleText = new TextDisplayBuilder().setContent(`# ${title}`);

      const dictionaryButton = new ButtonBuilder()
        .setLabel("View in Dictionary")
        .setStyle(ButtonStyle.Link)
        .setURL(`https://rechnik.chitanka.info/w/${encodeURIComponent(word)}`);

      const titleSection = new SectionBuilder()
        .addTextDisplayComponents(titleText)
        .setButtonAccessory(dictionaryButton);

      container.addSectionComponents(titleSection);

      let basicInfoContent = "";

      if (stressedWord) {
        basicInfoContent += `**Ударение:** ${stressedWord}\n`;
      }

      if (wordType) {
        basicInfoContent += `**Вид дума:** ${wordType.trim()}\n`;
      }

      if (wordClassClean) {
        if (typeLink) {
          basicInfoContent += `**Клас:** [${wordClassClean}](${typeLink})\n`;
        } else {
          basicInfoContent += `**Клас:** ${wordClassClean}\n`;
        }
      }

      if (basicInfoContent) {
        const basicInfoText = new TextDisplayBuilder().setContent(
          basicInfoContent
        );
        container.addTextDisplayComponents(basicInfoText);
      }

      container.addSeparatorComponents((separator) =>
        separator.setSpacing(SeparatorSpacingSize.Large)
      );

      let meaningText;
      let footer =
        "Source: rechnik.chitanka.info | Translation was generated by AI";
      let isAIGenerated = false;

      if (meaning) {
        const limitedMeaning = meaning.split("\n").slice(0, 5).join("\n");
        const englishTranslation = limitedMeaning
          ? await requestAI(
              `Meaning of this bulgarian word in english summarized: ${word}`
            )
          : "";
        meaningText =
          `## Значение\n${limitedMeaning}\n\n${englishTranslation}` ||
          "## Значение\nНяма информация";
      } else {
        isAIGenerated = true;
        meaningText =
          `## Значение\n${await requestAI(
            `Act like a modern Bulgarian dictionary. Provide only the grammatical information, part of speech, and linguistic details of the word ${word} in Bulgarian, without historical or cultural context. and short english translation below.`
          )}` || "## Значение\nНяма информация";
        footer =
          "No information on rechnik.chitanka.info found! | Part of the answer was generated by AI";
      }

      const meaningSection = new TextDisplayBuilder().setContent(meaningText);
      container.addTextDisplayComponents(meaningSection);

      const bgjargonData = await scrapeBgJargon(word);
      if (bgjargonData && bgjargonData.definitions.length > 0) {
        const bgjargonField = formatBgJargonField(bgjargonData);

        const bgjargonText = new TextDisplayBuilder().setContent(
          `## BGJargon\n${bgjargonField}`
        );

        container.addSeparatorComponents((separator) =>
          separator.setSpacing(SeparatorSpacingSize.Large)
        );

        container.addTextDisplayComponents(bgjargonText);

        footer = footer.replace(" | ", " | bgjargon.com | ");
      }

      if (synonyms) {
        container.addSeparatorComponents((separator) =>
          separator.setSpacing(SeparatorSpacingSize.Large)
        );

        const synonymsText = new TextDisplayBuilder().setContent(
          `## Синоними\n${synonyms}`
        );
        container.addTextDisplayComponents(synonymsText);
      }

      if (links) {
        container.addSeparatorComponents((separator) =>
          separator.setSpacing(SeparatorSpacingSize.Large)
        );

        const linksText = new TextDisplayBuilder().setContent(
          `## Връзки\n${links}`
        );
        container.addTextDisplayComponents(linksText);
      }

      const footerText = new TextDisplayBuilder().setContent(`-# ${footer}`);
      container.addTextDisplayComponents(footerText);

      await interaction.editReply({
        components: [container],
        flags: MessageFlags.IsComponentsV2,
      });
    } catch (error) {
      if (error.response && error.response.status === 404) {
        const $ = cheerio.load(error.response.data);
        const similarWords = $(".similar-words .data ul li")
          .map((i, el) => $(el).text().trim())
          .get();

        const container = new ContainerBuilder();

        const titleText = new TextDisplayBuilder().setContent(
          "# Думата не е намерена\nТърсената дума липсва в речника."
        );
        container.addTextDisplayComponents(titleText);

        if (similarWords.length > 0) {
          const similarWordsText = new TextDisplayBuilder().setContent(
            `## Подобни думи\n${similarWords.join(", ")}`
          );
          container.addTextDisplayComponents(similarWordsText);
        }

        await interaction.editReply({
          components: [container],
          flags: MessageFlags.IsComponentsV2,
        });
      } else {
        const container = new ContainerBuilder();
        const errorText = new TextDisplayBuilder().setContent(
          "# Грешка\nВъзникна грешка при търсенето на думата. Моля, опитайте отново по-късно."
        );
        container.addTextDisplayComponents(errorText);

        await interaction.editReply({
          components: [container],
          flags: MessageFlags.IsComponentsV2,
        });
      }
    }
  },
};

function formatBgJargonField(data) {
  const limitedDefinitions = data.definitions.slice(0, 3);

  return limitedDefinitions
    .map((def, index) => {
      let text = `**${index + 1}.** ${def.meaning}`;

      if (def.example) {
        text += `\n*"${def.example}"*`;
      }

      text += `\n-# 👍 ${def.votesYes}  👎 ${def.votesNo}\n\u200E\n`;

      return text;
    })
    .join("\n\n");
}

export { wordCommand };
